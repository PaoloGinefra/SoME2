import TextContainer from '../components/TextContainer'
import FadeBg from '../components/FadeBg'
import Spoiler from '../components/Spoiler'
import Caption from '../components/Caption'
import SketchIframe from '../components/SketchIframe'
import Example from '../sketches/Example'
import ExampleTimer from '../sketches/ExampleTimer'

<TextContainer>

    # All roads lead to Rome, a colorful problem

</TextContainer>

<FadeBg color = 'black'>
<TextContainer>

## An adventurous mathematician

It was a quiet evening in Gaussville. Avraham, an intrepid maths enthusiast, had just got home after a long day at uni.
Mindlessly scrolling through his phone and seeing the umpteenth online advertisement about cryptocurrencies, half curious, half surrendered, Avraham decided he would give them a go.

He just knew he wasn't going to be keen on finance or trading. He was although excited about trying to mine some Bitcoins, he had heard great things about them, so he set himself to do that.
Little did he know that he was taking _mining_ a bit too literally...
All geared up, hoping to squeeze in a little fitness in his search, he adventured into the "flatland mine".

Spanning only in a single vertical plane, the harsh tunnels were going to be a challenge to scout.

To the reader, Avraham may seem impulsive, almost hasty, but he is surely not unwary. In fact, he had made sure to bring a map of the mine with him.

We all know how mathematicians are though... while looking for a bitcoin, still exploring, Avraham got caught up in his thoughts and switched to autopilot, thinking back to a conjecture he had stumbled upon the day before.

Returning to the $\R$eal world he understood he had gotten lost. A brief moment of panic followed but soon enough, behind his glasses, his eyes flashed with frenzied glee.
He was suddenly a part of one of the problems he so loved to take on.

A quick glance at the map was enough to realise that he, unfortunately, could not pinpoint his location, the mine's corridors looked all the same and were too dark: it was impossible to find a reference point.

</TextContainer>

<SketchIframe
  src="/sketches/MazeExperience1/index.html?auto=false"
  height={500}
/>
<Caption>
  Use WASD or the arrows to explore the mine. Click on Avraham to show the
  mine's map
</Caption>

<TextContainer>

He took some deep breaths and tried to recollect himself, beginning to figure out a way to escape the labyrinth.
Exploring a little, he found that he only needed to choose what to do at the crossroads: he could just go down straight tunnels and go back on his steps to the last crossroad if he were to find a dead end.
He eventually stumbled into one. Turning left or right? Going up or down? He desperately needed a set of instructions that would lead him outside, no matter his location.

A bunch of questions naturally started popping into Avraham's mind:

- Does such a set even exist?
- Is there a way to find it quickly?
- How many instructions would the smallest one contain at best? and at worst?

</TextContainer>

<SketchIframe
  src="/sketches/MazeExperience1/index.html?auto=true"
  height={500}
/>
<Caption>
  Use WASD or the arrows to choose where Avraham should go at crossroads. Click
  on Avraham to show the mine's map
</Caption>

<TextContainer>

Avraham sat down and began to ponder, scribbling on the mine's dusty walls.
After a while — maybe hours, maybe days — he shouted in pure elation: _'EUREKA!!!_ I need to follow <Spoiler>RRURLURURU</Spoiler>.
He would soon find himself out of what had been his Plato's cave.

</TextContainer>
</FadeBg>

<FadeBg color='#192841'>
<TextContainer>
## An orientation problem fair and square
The year is 2122 and the world has changed so much: mankind has evolved past deadly diseases, metal straws have replaced plastic ones finally saving the environment and the Riemann hypothesis has been proven for a couple of years now. But above all of that, LEGO has ‒ at last ‒ decided to launch its first full-scale car model.

LEGO being LEGO, they had to build the factory of said cars entirely using legos... must be something about brand identity.

Grievously, a new way of moving objects in a straight line has not been found yet and conveyor belts are still the state of the art as far as chain production comes.
But it doesn’t end there: a series of poorly made choices (some of them regarding hibernation) has led you to be in charge of designing the contraptions for the LEGO car factory.

Today you are tackling a peculiar situation:

The last step to completing a car is to attach the roof. There are two conveyor belts perpendicular to each other: one for the almost-finished cars and the other for the roofs.
The problem is that roofs can come in four different orientations but only one of them fits the car!

### PICTURE WITH THE ORIENTATIONS

Your job is to design a setup to orient the pieces in the right way. Obviously, you can use lego bricks only, so no sensors, no motors, nothing like that.
Only passive solutions are allowed. Studying the shape of the roof you arrive at the conclusion that placing a series of bricks in just one of two vertical positions
should be enough to rotate the pieces from any orientation to every other.

</TextContainer>

<SketchIframe src="/sketches/conveyor-belt/index.html" height={400} />

<TextContainer>

Now the big problem is to find the right series. You try to solve the problem on your own but after a while you give up.
So you try a quick browser search (obviously using your mind) and you find an old paper that seems to give you all the answers.
The name of the author strucks you for being quite unusual. You really can't think about anybody else named Avrham.
Anyway, you try using the suggested algorithm and find the sequence "<Spoiler>GRRGR</Spoiler>"

</TextContainer>
</FadeBg>

<FadeBg color = 'black'>
  <TextContainer>

    ## What's behind the trick

    The findings of Avraham and future you almost resemble a magic trick. In fact
    something like this has been used in several ones.
    The ability to follow a set of instructions just to end up in the same
    configuration, no matter the starting one, is not only mind blowing but also
    hella useful. You may be surprised to know that this is a mathematical concept
    that has been studied for over half a centuary now and that it even has some problems still left unsolved.
    Let's dive a little deeper...

    ### The beauty of Automata / Time to abstract

    So, as we have just seen, the "trick" works in a wide variety of situations so, in a truly mathematical fashion, we need
    to use the power of abstraction to factor out all the scenario specific differences so as just to focus on the common part.

    First of all we can call the crossroads / roofs orientations / configurations "States" and the instructions to move between them "Transitions".

    In both the examples is clear that after reaching a state you are presented with a choice, you could either go Up, Down, Left or Right in the maze
    or choose the Green or Red brick for the legos. It's natural to identify transitions with symbols like U,D,L,R or G and R or 0,1,2,3 and so on.
    Now try and think of the last sequence of symbols you used to convey some sort of meaning... a <Spoiler>word</Spoiler>. That's how a sequence of instructions is called.

    Now, if we associate every symbol with a color, we can draw every state as a node and every transition as a colored arrow between nodes.
    We have now rappresented our setup as a directed graph.

    ### CANVAS WITH GRAPH

    Not only that, but now given a starting state and a word we can easily compute the landing state. It's just a metter of following the right arrows.

    ### AUTOMABOT DEMO

    So let's recap, we have constructed a not so black box that can take in a set of instructions, a word, and spits out a result.
    Doesn't it sounds even a little familiar? Careful because this time the answer is litterally before your eyes: <Spoiler>a Computer!</Spoiler>


    Well not quite, it's an abstract computer, a mathematical one. An automaton!

    Now try and execute the same word from the same starting state twice, do you expect the results to change?
    I mean it would be a problem if it did: if you ask your calculator what 2+2 is, you'd want the answer not to change every time, wouldn't you?
    These kind of processes are called deterministic.
    Furthermore, in this case the number of possible states has a limit, it's finite.

    We have built a **Deterministic Finite Automaton** also known as a DFA.

    ### GRAPH VERSION OF MAZE AND BELT WITH AUTOMABOT

    ### It's a matter of synchronization

    Now let's focus on the actual magic trick, i think it's time we give a name to what we are looking for.
    We have a bunch of different starting states and we want to bring them to just one.
    It's like we are a conductor and every member of the orchestra is playing out of synch, we need to
    find a sequence to reallign them, something like a synchronizing sequence... a **synchronizing word**.

    Okay cool, let's try not to follow Avraham's exemple. Let's ensure that our goal really exists *before* we embark in our wonderful quest.

    How can we know that for a given automaton a synchronizing word exists?

    This question was originally thought of in disguise, it had a different name and it was wearing glasses. We are really talking about a Superman-Clark Kent situation though.
    In the 70s Adler, Goodwyn and Weiss first conjured the "Road Coloring Problem".

    We already established the strong bond between automata and directed graphs, well originally the investigations leaned more on the graph side.
    A coloring of a directed graph is simply the assignmet of a color to each edge exiting a node such that no two edges exiting from the same node have the same color.
    It's basically what we did before assigning a symbol for each possible transition and then assigning a color for every symbol.

    The problem goes something like this: given a graph that satifies some conditions (we'll get to those in a moment),
    does a coloring of the edges that admits a synchronizing sequence exist?

    The conditions mentioned are there mainly to avoid trivial cases where a synchronizing word can't be found.
    Note that they are all sufficient, which means that when a graph verifies them all, a synch word has to exist (or rather may exist, that's the question) but
    when it doesn't, it's not implied the there's none.
    Let's try and work our way up to those. As in all great leggends there are three:

    1. A synchronizing word needs to work starting from any vertex of the graph, so naturally each symbol
    must be interpretable at each node. Let's say your symbols are A, B and C.
    If there is a node with just two edges coming out of it and we assign to them the letters A and B,
    what would happen if at that node we ask for C? It doesn't make sense, does it? The same goes for a node
    with four exiting edges. The number of edges coming out of a node is called out-degree, so
    in order for a synchronizing word to even make sense **the out-degree of every node needs to be constant**.

    2. A synchronizing word leads every node to a single one. So, first of all, that node must be reachable in one
    way or another from every node of the graph. Remember that a graph is just a set of nodes and edges so there's nothing
    against building one with edgeless nodes or isolated parts. To protect ourself from those we need to be able to
    reach every node starting from every other node via a valid route, or in other word, we need a **strongly connected graph**

    3. Unfotunatly now it gets a little more complicated. Picture a graph with just three nodes with out-degree of 1,
    where each node points to the one which does not point to it. You get a cycle, which is not that big of a deal per se.
    But this cycle is special. You'll never be able to make two different nodes collapse into one using a word. It's impossible.
    We need to avoid these kind of situations. Without entring in the gory details that are beyond the scope of this article,
    we need an **aperiodic graph**

    Now that trivial cases are out of the way, what more can we say about the existence of a synch coloring?
    Well the authors of the problem didn't arrive at a solution but they proposed a conjecture, the "Road Coloring conjecture".

    Hold on thight because it's about to get crazy.

    They simply conjectured that that's it: as long as those conditions are met,
    you are guaranteed that a synching coloring exists, they are sufficient.

    It can't be true, can it? Three simple checks are enough for something so oddly specific and powerful? It's almost unbelievable.
    Such sweet endings must live only in fairy tails. But indeed an ending was not. It was a conjecture, not a theorem.
    A still untouched hevenly city that can crumble at a single counter exemple, hidden behind the seemingly
    unsurmountable wall of a lack of a rigorous proof.

    40 years passed and the failed attempts of hundreds of mathematicians continued stacking up.
    It was thanks to Avraham Trahtman in the year 2007 that we can now talk about the end of this story.
    He finally proved the conjecture, the dream became reality and they all lived happily ever after.
    Except for us because this is just the beginning...

    ### Synchcronizing words are sharper than swords

    The "Road Coloring theorem" is really amazing but it doesn't tell us anything on how to find the synchronizing words.

    Let's start by noticing that when a graph allows a synching word to exist, it automatically implies
    that there are infinite many of them.
    That's because if we combine a synch word with any other possible combination of symbols we still get a synching word.
    So let's refine once more our target, we want to find the shortest synching word for a given automaton.

    For this kind of task it may be useful to tuckle the problem from more of a computer sciency perspective.
    We are looking for an algorithm.

    The fist step of our algorithm has to be checking the existence of the word, and we can easily do that with the Road coloring theorem.

    Then we need to find the word.
    A basic approach would be to methodically test increasingly longer words against random initial states to see if they are synchronizing.
    The core idea is not bad, in fact it's the one behind every synching word finding algorithm. But it needs quite a bit of polish.

    What about instead of seeing what happens to a single initial state we apply a transition to a set of states
    recording where each of them lands? Now we can explore all the different possibilities starting from
    a set of all the possible states and gradually appling all the possible transitions.
    Then we apply all the possible transitions to the resulting sets of the previous step
    and so on until we find a set with just one state.

    Proceeding mindlessly in this way we can build a so called tree.
    Mind that in this way the order by which we check the transitions matters and we are not ensured to find the shortest sequence.
    The game changes if we keep track of the sets we encounter along the way. In this way we can keep going only when
    we are presented with a new set.

    ### CANVAS WITH AN AUTOMABOT PER STARTING NODE




    ### There's more than mazes and lego bricks

  </TextContainer>
</FadeBg>

<FadeBg color='#192841'>
  <TextContainer>
    I dont' know where this sketch should be placed
  </TextContainer>

  <SketchIframe
    src="/sketches/MazeExperience2/index.html"
    height={500}
  />
</FadeBg>

<TextContainer>
  Spoiler: <Spoiler>scemo chi legge</Spoiler>
</TextContainer>

<TextContainer>
## Math (with $\KaTeX$)

Lift($L$) can be determined by Lift Coefficient ($C_L$) like the following
equation.

$$
L = \frac{1}{2} \rho v^2 S C_L
$$

## GFM stuff

www.example.com, https://example.com, and contact@example.com.

A note[^1]

[^1]: Big note.

~one~ or ~~two~~ tildes.

| a       | b           |       c |     d      |
| ------- | :---------- | ------: | :--------: |
| This is | a long line | of text | in a table |

- [ ] to do
- [x] done

</TextContainer>

<TextContainer>
[A link to Google](https://google.com)

![A suspicious sine wave](/img/sinus.jpg)

</TextContainer>
